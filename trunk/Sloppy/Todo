
BUGFIXES TO BE DONE
====================

- projectio: import_from_table stuff.
  => right now, the dataset is loaded because the datawin has a get_array
     call. Of course we must do this somehow different....
     maybe set _array to property(..., set_array)

- dataset signal 'notify' => dataview does not update properly...

- Importer: remove checkboxes from widgets....

- DatasetView: allow to change field name 

- Allow to specify format for column view (e.g. %2.3f for floats)

- when switching the view, we first should leave focus, because otherwise
  you might see remnants from combo boxes

- if clicking on 'apply' or any other button in the layer window,
  we need to apply all changes that are not yet active.  Maybe by
  moving focus to the current button?

- close matplotlib backend, then edit its plot again --> I think this will
  cause an error because the backend has not been properly closed.

- check if we really want to have None values for some object properties, e.g.
  line.label, ...

- extra option: autotitles: if set to off, then only plots that do have a
  label are given a title (gnuplot: set key noautotitles)

- aspect ratio of figures should be preserved.

- What if we have two templates for the same extension?
  -> either ask the user what to do
  -> or prefer the template that is on the top.  This would
     require a 'move up' and 'move down' button in the preferences
     dialog

- don't update tools window if it is hidden, i.e. disconnect signals!

- Signals.connect_once -> requires an additional flag in the SignalContainer


TOOLBOX CONCEPT:
----------------
- All tools in a toolbox belong to the toolbox's backend, i.e. matplotlib backend.

  One tool can store the settings for a specific matplotlib window.

  The question is now: Can there be two tool instances, e.g. 2
  PeakFinder Tools? Yes, why not? The Tool itself creates a temporary line
  in the backend. This line must be saved in the backend, so that it is
  displayed, with some temp attribute turned on. The PeakFinderTool instance
  knows the name of the line _pft, __pft_2, ... and will replace exactly that
  line.  The tool could save this information not in the PFT instance, but
  in the backend.

  backend.tool_data[object_id] where object_id is the id of the PeakFinderTool,
  so it would be unique for instances. If a tool is closed, then it would be 
  very easy to discard that data.







